Sean wrote load instruciton, print instruction, printing current state of virtual machine
Satya and Brody wrote fetch, execute, base, main and the header
All helped debug and write comments

#include "vm.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* TODO
 * write printStack
 * fix halt issue
 * ?
 */

int main(int argc, char *argv[]) {

        if (argc != 2) usage(argv[0]);

        int i = 0
        loadInstructions(argv[1]);
        while(i++ < 16) {
                fetch();
                execute();
        printInstruction(&ir);
        }
        return 0;
}

// if there's no filename, tells you to put a filename
void usage(const char *pname) {
    printf("%s: usage: %s input-file\n", pname, pname);
    ABORT("no input file provided\n");
}

// loads the instructions from the file
void loadInstructions(const char* filePath) {
    FILE *source = fopen(filePath, "r");
    char buf[32];
    char token[32];
    int i;

    if (!source) ABORT("could not load file %s\n", filePath);

    printf("PL/0 code:\n\n");
        // scan in the code and print it out as you get it
    for (i = 0; fscanf(source, "%d %d %d", &code[i].op, &code[i].l, &code[i].m)==3; i++) {
        code[i].line = i;
        printInstruction(code + i);
        putchar('\n');
    }
}

// prints the instruction given
void printInstruction(const Instruction* i) {
    // different parts of the instructions
    static const char *NAMES[] = {
        "__", "LIT", "OPR", "LOD", "STO", "CAL", "INC",
        "JMP", "JPC", "SIO"
    };
    static const char *OPNAMES[] = {
        "RET", "NEG", "ADD", "SUB", "MUL", "DIV", "ODD",
        "MOD", "EQL", "NEQ", "LSS", "LEQ", "GTR", "GEQ"
    };
    static const char *SIONAMES[] = {
        "OUT", "INP", "HLT"
    };

    // given the different names print out the instruction
    printf("%4d  %s\t%d\t%4d", i->line,
            i->op == 2 ?
                OPNAMES[i->m] :
                i->op == 9 ?
                    SIONAMES[i->m] :
                    NAMES[i->op]
            , i->l, i->m
    );
}

// fetches the instruction and increments pc
void fetch(void) {
        ir = code[pc];
        pc += 1;

}

// executes an instruction
void execute(void) {
        // switch statmeent based on the op code
        switch(ir.op) {
                // push m onto stack
                case 1:
                        sp += 1;
                        stack[sp] = ir.m;
                        break;
                // perform arithmetic
                case 2:
                        // switch case for different operations
                        switch(ir.m) {
                                // RET
                                case 0:
                                        sp = bp - 1;
                                        pc = stack[sp + 4];
                                        bp = stack[sp+3];
                                        break;
                                // NEG
                                case 1:
                                        stack[sp] *= -1;
                                        break;
                                // ADD
                                case 2:
                                        sp -= 1;
                                        stack[sp] += stack[sp+1];
                                        break;
                                // SUB
                                case 3:
                                        sp -= 1;
                                        stack[sp] -= stack[sp+1];
                                        break;
                                // MUL
                                case 4:
                                        sp -= 1;
                                        stack[sp] *= stack[sp+1];
                                        break;
                                // DIV
                                case 5:
                                        sp -= 1;
                                        stack[sp] /= stack[sp+1];
                                        break;
                                // ODD
                                case 6:
                                        stack[sp] %= 2;
                                        break;
                                // MOD
                                case 7:
                                        stack[sp] -= 1;
                                        stack[sp] = stack[sp] % stack[sp+1];
                                        break;
                                // EQL
                                case 8:
                                        sp -= 1;
                                        stack[sp] = (stack[sp] == stack[sp+1]);
                                        break;
                                // NEQ
                                case 9:
                                        sp -= 1;
                                        stack[sp] = (stack[sp] != stack[sp+1]);
                                        break;
                                // LSS
                                case 10:
                                        sp -= 1;
                                        stack[sp] = (stack[sp] < stack[sp+1]);
                                        break;
                                // LEQ
                                case 11:
                                        sp -= 1;
                                        stack[sp] = (stack[sp] <= stack[sp+1]);
                                        break;
                                // GTR
                                case 12:
                                        sp -= 1;
                                        stack[sp] = (stack[sp] > stack[sp+1]);
                                        break;
                                // GEQ
                                case 13:
                                        sp -= 1;
                                        stack[sp] = (stack[sp] >= stack[sp+1]);
                                        break;
                        }
                // LOD
                case 3:
                        sp += 1;
                        stack[sp] = stack[base(ir.l, bp) + ir.m];
                        break;
                // STO
                case 4:
                        stack[base(ir.l, bp) + ir.m];
                        sp -= 1;
                        break;
                // CAL
                case 5:
                        stack[sp+1] = 0;
                        stack[sp+2] = base(ir.l, bp);
                        stack[sp+3] = bp;
                        stack[sp+4] = pc;
                        bp += 1;
                        pc = ir.m;
                        break;
                // INC
                case 6:
                        sp += ir.m;
                        break;
                // JMP
                case 7:
                        pc = ir.m;
                        break;
                // JPC
                case 8:
                        if (!stack[sp]) pc = ir.m;
                        sp -= 1;
                        break;
                // SIO
                case 9:
                        // Switch based on M
                        switch(ir.m) {
                                // OUT
                                case 0:
                                        printf("%d\n", stack[sp]);
                                        sp -= 1;
                                        break;
                                // INP
                                case 1:
                                        sp += 1;
                                        scanf("%d", &stack[sp]);
                                        break;
                                // HLT
                                case 2:
                                        exit(0);
                                        break;

                        }
                        break;

        }

}

// Change bp based on L
int base(int level, int bp) {
        while(level > 0) {
                bp = stack[bp+1];
                level--;
        }
        return bp;
}
